<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸŽ¬ Offline Video Reverser</title>

    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0d6efd">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Video Reverser">

    <style>
        /* --- Global Styles & Resets --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
            line-height: 1.6;
        }

        /* --- Main Container --- */
        .container {
            background-color: #ffffff;
            padding: 25px 30px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            width: 100%;
            max-width: 750px;
            text-align: center;
            box-sizing: border-box;
        }

        /* --- Headings and Text --- */
        h1 {
            color: #0d6efd;
            margin-bottom: 15px;
            font-size: 2.2em;
        }

        .container p:first-of-type {
            color: #555;
            margin-bottom: 25px;
            font-size: 1.05em;
        }

        /* --- App Info Section --- */
        .app-info {
            background-color: #e7f3ff;
            border: 1px solid #b8daff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 25px;
            text-align: left;
        }

        .app-info h3 {
            color: #0d6efd;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .app-info ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .app-info li {
            margin-bottom: 5px;
            font-size: 0.95em;
        }

        /* --- Install PWA Banner --- */
        .install-banner {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            display: none;
        }

        .install-banner button {
            background-color: #198754;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 0.9em;
        }

        .install-banner button:hover {
            background-color: #157347;
        }

        /* --- File Upload Styling --- */
        .upload-label {
            display: inline-block;
            padding: 12px 28px;
            background-color: #198754;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            margin-bottom: 25px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .upload-label:hover {
            background-color: #157347;
        }
        .upload-label:active {
            transform: translateY(1px);
        }

        input[type="file"] {
            display: none;
        }

        /* --- Video Players Section --- */
        .video-players {
            display: flex;
            flex-direction: column;
            gap: 25px;
            margin-bottom: 30px;
        }

        .video-wrapper {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            flex: 1;
        }

        .video-wrapper h2 {
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 1.25em;
            color: #495057;
        }

        video {
            width: 100%;
            max-height: 320px;
            border-radius: 6px;
            background-color: #000;
            display: block;
        }

        /* --- Action Buttons --- */
        .action-button {
            display: inline-block;
            padding: 12px 28px;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out, opacity 0.2s ease, transform 0.1s ease;
            margin: 10px 5px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .action-button:active {
            transform: translateY(1px);
        }

        #reverseButton {
            background-color: #0d6efd;
        }
        #reverseButton:not(:disabled):hover {
            background-color: #0b5ed7;
        }

        #downloadButton {
            background-color: #fd7e14;
            text-decoration: none;
        }
        #downloadButton:not([style*="display:none"]):hover {
            background-color: #f06c04;
        }

        .action-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            opacity: 0.65;
        }

        /* --- Status and Progress --- */
        #status {
            margin-top: 25px;
            font-size: 1em;
            color: #212529;
            min-height: 24px;
            font-weight: 500;
        }

        #progressBar {
            width: 100%;
            height: 16px;
            margin-top: 12px;
            border-radius: 8px;
            display: none;
            appearance: none;
            border: 1px solid #ced4da;
        }
        #progressBar::-webkit-progress-bar {
            background-color: #e9ecef;
            border-radius: 8px;
        }
        #progressBar::-webkit-progress-value {
            background-color: #198754;
            border-radius: 8px;
            transition: width 0.2s ease-out;
        }
        #progressBar::-moz-progress-bar {
            background-color: #198754;
            border-radius: 8px;
            transition: width 0.2s ease-out;
        }

        /* --- Performance Info --- */
        .performance-info {
            background-color: #fff3cd;
            border: 1px solid #ffecb5;
            border-radius: 8px;
            padding: 10px 15px;
            margin-top: 15px;
            font-size: 0.9em;
            color: #664d03;
            display: none;
        }

        /* --- Responsive Design --- */
        @media (min-width: 700px) {
            .video-players {
                flex-direction: row;
                justify-content: space-between;
            }
        }

        /* --- Accessibility --- */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¬ Video Reverser</h1>
        <p>Upload a video, reverse it, and download. This tool works entirely in your browser, even offline!</p>

        <div id="installBanner" class="install-banner">
            ðŸ“± Install this app on your device for faster access and offline use!
            <button id="installButton">Install App</button>
        </div>

        <div class="app-info">
            <h3>ðŸš€ Performance Optimizations</h3>
            <ul>
                <li><strong>Smart Frame Extraction:</strong> Extracts 30 frames per second for optimal quality/speed balance</li>
                <li><strong>720p Optimization:</strong> Automatically scales videos to 720p for faster processing</li>
                <li><strong>Lossless Compression:</strong> Uses high-quality encoding to preserve video quality</li>
                <li><strong>Progressive Web App:</strong> Install for offline use and faster loading</li>
                <li><strong>Memory Efficient:</strong> Optimized algorithms to handle larger videos smoothly</li>
            </ul>
        </div>

        <label for="videoUpload" class="upload-label">ðŸ“¤ Select Video</label>
        <input type="file" id="videoUpload" accept="video/*" class="sr-only">

        <div class="video-players">
            <div class="video-wrapper">
                <h2>Original Video</h2>
                <video id="originalVideo" controls muted playsinline aria-label="Original video player"></video>
            </div>
            <div class="video-wrapper">
                <h2>Reversed Video</h2>
                <video id="reversedVideo" controls playsinline aria-label="Reversed video player"></video>
                <p style="text-align: right; margin-top: 4px; font-size: 0.9em;">Duration: <span id="reversedVideoDurationDisplay">--:--</span></p>
            </div>
        </div>


<label style="margin-top:15px; display:block;">FPS:
    <input id="fpsInput" type="number" min="5" max="60" value="30"
           style="width: 60px; padding: 4px; margin-left: 8px;" />
</label>
<p id="fpsWarning" style="font-size: 0.8em; color: #d9534f; margin-top: 4px; min-height: 1em;"></p>
<button id="reverseButton" class="action-button" disabled>ðŸ”„ Reverse Video</button>
        <a id="downloadButton" class="action-button" style="display:none;" download="reversed_video.webm" role="button">ðŸ“¥ Download Reversed Video</a>

        <p id="status" aria-live="polite"></p>
        <progress id="progressBar" value="0" max="100" aria-label="Video processing progress"></progress>
        <p id="recordingFormatDisplay" style="font-size: 0.85em; color: #555; margin-top: 5px; min-height: 1em;"></p>
        <div id="performanceInfo" class="performance-info"></div>

        <canvas id="frameCanvas" style="display:none;" aria-hidden="true"></canvas>
    </div>

    <script>
        console.log("Video Reverser main script started");

        // --- IndexedDB Setup ---
        const DB_NAME = 'videoReverserDB_v1';
        const STORE_NAME = 'framesStore';
        let db; // Will hold the database instance

        /**
         * Initializes the IndexedDB database and object store.
         * @returns {Promise<IDBDatabase>} A promise that resolves with the database instance or rejects on error.
         */
        function initDB() {
            return new Promise((resolve, reject) => {
                if (db) { // If db is already initialized
                    resolve(db);
                    return;
                }

                console.log(`[DB] Initializing database: ${DB_NAME}`);
                const request = indexedDB.open(DB_NAME, 1); // Version 1

                request.onerror = (event) => {
                    console.error('[DB] Error opening database:', event.target.error);
                    reject('Error opening IndexedDB: ' + event.target.error);
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log(`[DB] Database "${DB_NAME}" opened successfully.`);
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    console.log('[DB] Database upgrade needed or initial setup.');
                    const tempDb = event.target.result;
                    if (!tempDb.objectStoreNames.contains(STORE_NAME)) {
                        console.log(`[DB] Creating object store: ${STORE_NAME}`);
                        // Using autoIncrementing key for simplicity for now.
                        // Could also use a keyPath like 'id' if objects have a unique 'id' property.
                        const objectStore = tempDb.createObjectStore(STORE_NAME, { autoIncrement: true });

                        // Create an index on 'sessionId' to allow fetching all frames for a session.
                        // And an index on 'sessionId_frameNumber' for sorting / specific frame retrieval if needed.
                        objectStore.createIndex('sessionId_idx', 'sessionId', { unique: false });
                        objectStore.createIndex('sessionId_frameNumber_idx', ['sessionId', 'frameNumber'], { unique: true });
                        console.log('[DB] Object store and indexes created.');
                    } else {
                        console.log(`[DB] Object store "${STORE_NAME}" already exists.`);
                    }
                };
            });
        }

        /**
         * Deletes ALL frames from the framesStore.
         * @returns {Promise<void>} A promise that resolves when deletion is complete or rejects on error.
         */
        function clearAllFramesFromDB() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    console.warn('[DB] Database not initialized. Cannot clear frames.');
                    resolve();
                    return;
                }
                console.log(`[DB] Clearing ALL frames from store: ${STORE_NAME}`);
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.clear(); // Clears all data in the object store

                request.onsuccess = () => {
                    console.log(`[DB] All frames cleared from ${STORE_NAME}.`);
                    resolve();
                };
                request.onerror = (event) => {
                    console.error('[DB] Error clearing all frames:', event.target.error);
                    reject('Error clearing all frames from DB: ' + event.target.error);
                };
                // Transaction oncomplete/onerror can be added as above if needed for more detail
            });
        }

        /**
         * Adds a frame object to the framesStore in IndexedDB.
         * @param {object} frameData - The frame object (e.g., { sessionId, frameNumber, frameBlob, originalName }).
         * @returns {Promise<number>} A promise that resolves with the key of the added item or rejects on error.
         */
        function addFrameToDB(frameData) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    console.error('[DB] Database not initialized. Cannot add frame.');
                    reject('Database not initialized.');
                    return;
                }
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.add(frameData);

                request.onsuccess = (event) => {
                    // console.log('[DB] Frame added successfully with key:', event.target.result);
                    resolve(event.target.result);
                };
                request.onerror = (event) => {
                    console.error('[DB] Error adding frame:', event.target.error);
                    reject('Error adding frame to DB: ' + event.target.error);
                };
            });
        }

        // --- Service Worker Registration ---
        // This section handles the registration of the service worker.
        // Service workers enable Progressive Web App (PWA) features like offline caching and background updates.
        if ('serviceWorker' in navigator) { // Check if the browser supports service workers
            window.addEventListener('load', () => { // Register the service worker after the page has loaded
                navigator.serviceWorker.register('service-worker.js') // Path to the service worker file
                    .then(registration => {
                        console.log('Service Worker registered successfully: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('Service Worker registration failed: ', registrationError);
                    });
            });
        }

        // --- PWA Install Functionality ---
        // This section manages the PWA installation prompt.
        let deferredPrompt; // Stores the 'beforeinstallprompt' event
        const installBanner = document.getElementById('installBanner'); // The banner inviting users to install the PWA
        const installButton = document.getElementById('installButton'); // The button to trigger the install prompt

        // Listen for the 'beforeinstallprompt' event, which is fired when the browser determines the app is installable.
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault(); // Prevent the default browser install prompt
            deferredPrompt = e; // Save the event so it can be triggered later
            installBanner.style.display = 'block'; // Show the custom install banner
        });

        // Handle clicks on the custom install button.
        installButton.addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt(); // Show the browser's install prompt
                const { outcome } = await deferredPrompt.userChoice; // Wait for the user's decision
                console.log(`User response to the install prompt: ${outcome}`);
                deferredPrompt = null; // The prompt can only be used once
                installBanner.style.display = 'none'; // Hide the custom banner
            }
        });

        // Listen for the 'appinstalled' event, which is fired after the PWA has been installed.
        window.addEventListener('appinstalled', () => {
            installBanner.style.display = 'none'; // Hide the banner if the app is installed
            console.log('PWA was installed successfully.');
        });

        // --- DOM Element Selection ---
        // Get references to various HTML elements to interact with them via JavaScript.
        const videoUpload = document.getElementById('videoUpload'); // Input element for video file selection
        const originalVideo = document.getElementById('originalVideo'); // Video player for the original video
        const reversedVideo = document.getElementById('reversedVideo'); // Video player for the reversed video
        reversedVideo.addEventListener('loadedmetadata', () => {
            console.log('Reversed video (onloadedmetadata) reported duration:', reversedVideo.duration);
            const durationDisplay = document.getElementById('reversedVideoDurationDisplay');
            if (durationDisplay) {
                if (reversedVideo.duration && reversedVideo.duration !== Infinity && !isNaN(reversedVideo.duration) && reversedVideo.duration > 0) {
                    durationDisplay.textContent = formatTime(reversedVideo.duration);
                } else if (originalVideo.duration && originalVideo.duration !== Infinity && !isNaN(originalVideo.duration)) {
                    // If reversedVideo.duration is invalid, use originalVideo.duration as a fallback
                    console.log('Reversed video duration is invalid, using original video duration as fallback for display.');
                    durationDisplay.textContent = formatTime(originalVideo.duration) + ' (actual)';
                } else {
                    durationDisplay.textContent = '--:--'; // Fallback if no valid duration is found
                }
            }
        });
        const reverseButton = document.getElementById('reverseButton'); // Button to start the video reversal process
        const downloadButton = document.getElementById('downloadButton'); // Button to download the reversed video
        const statusDisplay = document.getElementById('status'); // Element to display status messages
        const progressBar = document.getElementById('progressBar'); // Progress bar for video processing
        const performanceInfo = document.getElementById('performanceInfo'); // Element to display video performance metrics
        const frameCanvas = document.getElementById('frameCanvas'); // Canvas element used for frame extraction and manipulation
        const ctx = frameCanvas.getContext('2d'); // 2D rendering context for the canvas

        const fpsInput = document.getElementById('fpsInput'); // Ensure it's defined if not already
        const fpsWarning = document.getElementById('fpsWarning');

        if (fpsInput && fpsWarning) { // fpsWarning is already defined globally or in an outer scope
            fpsInput.addEventListener('input', function() {
                let fpsValue = parseInt(this.value, 10); // Use let to allow re-assignment

                if (!isNaN(fpsValue)) {
                    if (fpsValue < 5) {
                        this.value = 5; // Clamp input field value
                        fpsValue = 5;   // Update fpsValue for current logic
                    } else if (fpsValue > 60) {
                        this.value = 60; // Clamp input field value
                        fpsValue = 60;   // Update fpsValue for current logic
                    }
                } else {
                    // Handle cases where input is not a valid number, e.g., empty string
                    // Depending on desired behavior, could set to default, or rely on HTML validation popup
                    // For now, if it's NaN, subsequent logic for warning/button will likely treat it as invalid.
                    // Or, we could force a default if it becomes NaN after parsing.
                    // Let's ensure that if it's NaN, the button gets disabled and warning is cleared.
                    // The updateReverseButtonState() and warning logic should correctly handle NaN fpsValue.
                }

                // Update warning (this logic might become mostly moot if clamping is effective)
                // The warning was for "fpsValue > 0 && fpsValue < 5". Since it's clamped to 5,
                // this specific warning text will not show. We can remove it or change it.
                // For now, let's keep the structure but it won't trigger the "less than 5" text.
                // A new, different warning could be added if desired, e.g., "Value clamped to 5-60 range".
                // Let's remove the old warning text logic as it's now handled by clamping.
                fpsWarning.textContent = ''; // Clear any previous general warning.
                                             // Specific warning for "clamped" could be added here if needed.

                updateReverseButtonState(); // Call this with the (potentially clamped) fpsValue
            });
        }

        // --- State Variables ---
        // These variables store the application's state during the video reversal process.

        // Call initDB early on script load, perhaps after DOM elements are defined
        // or when the application is ready. For now, let's call it to ensure it runs.
        // We'll handle the promise to ensure DB is ready before operations.
        initDB().then(() => {
            console.log('[DB] Database ready for use.');
        }).catch(error => {
            console.error('[DB] Critical: Database initialization failed.', error);
            // Maybe disable app functionality or show error to user
            statusDisplay.textContent = 'Error: Local database could not be initialized. App may not work correctly.';
            if(reverseButton) reverseButton.disabled = true;
        });

        let sourceVideoFile = null; // Stores the selected video file object
        // let extractedFrames = []; // Array to store extracted video frames as data URLs - NO LONGER USED FOR FRAME DATA
        const MAX_RESOLUTION = 720; // Target resolution for video processing (720p optimization)
        let currentOriginalVideoObjectURL = null; // Stores the object URL for the original video, used for display
        let currentReversedVideoObjectURL = null; // Stores the object URL for the reversed video, used for display and download
        let processingStartTime = null; // Timestamp for when video processing begins, used for performance measurement

        // --- Utility Functions ---

        /**
         * Calculates optimal dimensions for video processing, scaling down to a maximum resolution (MAX_RESOLUTION)
         * while maintaining the aspect ratio. This helps in speeding up the processing.
         * @param {number} width - Original width of the video.
         * @param {number} height - Original height of the video.
         * @param {number} maxRes - The maximum dimension (width or height) allowed.
         * @returns {object} An object containing the calculated optimal width and height.
         */
        function calculateOptimalDimensions(width, height, maxRes = MAX_RESOLUTION) {
            if (width <= maxRes && height <= maxRes) { // If already within limits
                return { width, height };
            }

            const aspectRatio = width / height; // Calculate aspect ratio
            if (width > height) { // Landscape or square video
                return { // Scale width down to maxRes, calculate height based on aspect ratio
                    width: maxRes,
                    height: Math.round(maxRes / aspectRatio)
                };
            } else { // Portrait or square video
                return { // Scale height down to maxRes, calculate width based on aspect ratio
                    width: Math.round(maxRes * aspectRatio),
                    height: maxRes
                };
            }
        }

        /**
         * Formats file size in bytes to a human-readable string (KB, MB, GB).
         * @param {number} bytes - The file size in bytes.
         * @returns {string} A human-readable file size string.
         */
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024; // Base for conversion (1024 bytes = 1 KB)
            const sizes = ['Bytes', 'KB', 'MB', 'GB']; // Units for file size
            const i = Math.floor(Math.log(bytes) / Math.log(k)); // Determine the appropriate unit
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]; // Format and return
        }

        /**
         * Formats time in seconds to a "minutes:seconds" string.
         * @param {number} seconds - The time duration in seconds.
         * @returns {string} A formatted time string (e.g., "2:35").
         */
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60); // Calculate minutes
            const secs = Math.floor(seconds % 60); // Calculate remaining seconds
            return `${mins}:${secs.toString().padStart(2, '0')}`; // Format and return
        }

        function updateReverseButtonState() {
            if (!reverseButton || !fpsInput || !originalVideo) return; // Ensure elements are present

            const fpsValue = parseInt(fpsInput.value, 10);
            const isVideoReady = sourceVideoFile && originalVideo.readyState >= originalVideo.HAVE_METADATA && originalVideo.videoWidth > 0 && originalVideo.videoHeight > 0;

            if (isVideoReady && !isNaN(fpsValue) && fpsValue >= 5) {
                reverseButton.disabled = false;
            } else {
                reverseButton.disabled = true;
            }
        }

        // --- File Upload and Initial Video Setup ---
        // This event listener handles the selection of a video file by the user.
        videoUpload.addEventListener('change', function(event) {
            sourceVideoFile = event.target.files[0];
            if (sourceVideoFile) {
                processingStartTime = performance.now(); // Record start time for performance metrics

                // Revoke any existing object URL for the original video to free up memory
                if (currentOriginalVideoObjectURL) {
                    URL.revokeObjectURL(currentOriginalVideoObjectURL);
                }

                // Create a new object URL for the selected file. This allows the video to be displayed in the <video> element.
                currentOriginalVideoObjectURL = URL.createObjectURL(sourceVideoFile);
                originalVideo.src = currentOriginalVideoObjectURL; // Set the source of the original video player

                // Event listener for when the video metadata (like duration, dimensions) is loaded.
                originalVideo.onloadedmetadata = () => {
                    // Basic validation for video dimensions
                    if (originalVideo.videoWidth === 0 || originalVideo.videoHeight === 0) {
                        statusDisplay.textContent = 'Error: Video dimensions are zero. Is the file a valid video?';
                        reverseButton.disabled = true;
                        return;
                    }

                    // Calculate the optimal dimensions for processing based on MAX_RESOLUTION
                    const optimalDims = calculateOptimalDimensions(
                        originalVideo.videoWidth,
                        originalVideo.videoHeight
                    );

                    // Set the canvas dimensions to the optimal processing size
                    frameCanvas.width = optimalDims.width;
                    frameCanvas.height = optimalDims.height;

                    // reverseButton.disabled = false; // Enable the reverse button
                    updateReverseButtonState();
                    statusDisplay.textContent = 'Video loaded. Ready to reverse.';

                    // Display video information (file size, duration, resolution)
                    const fileSize = formatFileSize(sourceVideoFile.size);
                    const duration = formatTime(originalVideo.duration);
                    const resolution = `${originalVideo.videoWidth}x${originalVideo.videoHeight}`;
                    const optimizedRes = `${optimalDims.width}x${optimalDims.height}`;

                    performanceInfo.innerHTML = `
                        <strong>Video Info:</strong> ${fileSize} â€¢ ${duration} â€¢ ${resolution}
                        ${resolution !== optimizedRes ? ` â†’ Optimized to ${optimizedRes}` : ''}
                    `;
                    performanceInfo.style.display = 'block'; // Show performance info

                    // Reset UI elements for a new video
                    downloadButton.style.display = 'none'; // Hide download button
                    // Clear any previously reversed video and its object URL
                    if (reversedVideo.src && reversedVideo.src.startsWith('blob:')) {
                        URL.revokeObjectURL(reversedVideo.src);
                    }
                    reversedVideo.src = ''; // Clear the reversed video player
                    progressBar.style.display = 'none'; // Hide progress bar
                    progressBar.value = 0; // Reset progress bar
                    const formatDisplay = document.getElementById('recordingFormatDisplay');
                    if (formatDisplay) {
                        formatDisplay.textContent = ''; // Clear it
                    }
                };

                // Error handling for video loading issues
                originalVideo.onerror = () => {
                    statusDisplay.textContent = 'Error loading video. The file might be corrupt or an unsupported format.';
                    // reverseButton.disabled = true; // Old line
                    // Revoke the object URL if there's an error to prevent memory leaks
                    if (currentOriginalVideoObjectURL) {
                        URL.revokeObjectURL(currentOriginalVideoObjectURL);
                        currentOriginalVideoObjectURL = null;
                    }
                    updateReverseButtonState(); // Ensure button is disabled
                };
                statusDisplay.textContent = 'Loading video...'; // Initial status message
            } else {
                // No file selected or selection cleared
                if (currentOriginalVideoObjectURL) {
                    URL.revokeObjectURL(currentOriginalVideoObjectURL);
                    currentOriginalVideoObjectURL = null;
                }
                originalVideo.src = '';
                sourceVideoFile = null; // Explicitly set sourceVideoFile to null
                statusDisplay.textContent = 'No video selected.';
                performanceInfo.style.display = 'none';
                downloadButton.style.display = 'none';
                if (reversedVideo.src && reversedVideo.src.startsWith('blob:')) {
                    URL.revokeObjectURL(reversedVideo.src);
                }
                reversedVideo.src = '';
                progressBar.style.display = 'none';
                progressBar.value = 0;
                const fpsWarning = document.getElementById('fpsWarning');
                if (fpsWarning) fpsWarning.textContent = '';

                updateReverseButtonState(); // Ensure button is disabled
            }
        });

        // --- Video Reversal Process ---
        // Event listener for the "Reverse Video" button.
        reverseButton.addEventListener('click', async function() {
            // At the very start of the click listener
            statusDisplay.textContent = 'Initializing and cleaning up previous session data...';
            progressBar.style.display = 'block'; // Show progress early
            progressBar.value = 0;

            try {
                await clearAllFramesFromDB(); // Clear all frames before starting new session
                console.log('[PROCESS] Previous frames cleared from DB.');
            } catch (cleanupError) {
                console.error('[PROCESS] Failed to clear previous frames from DB:', cleanupError);
                statusDisplay.textContent = 'Error during cleanup. Please try again.';
                // Potentially disable button and return
                updateReverseButtonState();
                return;
            }

            // Validations before starting the reversal process
            if (!originalVideo.src || originalVideo.readyState < originalVideo.HAVE_METADATA) {
                statusDisplay.textContent = 'Please load a video first or wait for it to load.';
                return;
            }
            if (originalVideo.duration === Infinity || isNaN(originalVideo.duration) || originalVideo.duration <= 0) {
                statusDisplay.textContent = 'Cannot process video: Invalid duration or live stream.';
                return;
            }

            processingStartTime = performance.now(); // Record start time for performance measurement
            // Disable buttons and reset UI during processing
            reverseButton.disabled = true;
            downloadButton.style.display = 'none';
            const formatDisplayClear = document.getElementById('recordingFormatDisplay');
            if (formatDisplayClear) {
                formatDisplayClear.textContent = ''; // Clear it
            }
            statusDisplay.textContent = 'Step 1: Scaling and preparing canvas...';
            progressBar.style.display = 'block';
            progressBar.value = 0;
            // extractedFrames = []; // Clear any previously extracted frames - NO LONGER USED

            const currentSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            console.log(`[PROCESS] Starting new session: ${currentSessionId}`);

            // Revoke any existing object URL for the reversed video
            if (currentReversedVideoObjectURL) {
                URL.revokeObjectURL(currentReversedVideoObjectURL);
                currentReversedVideoObjectURL = null;
            }
            if (reversedVideo.src && reversedVideo.src.startsWith('blob:')) {
                URL.revokeObjectURL(reversedVideo.src);
                reversedVideo.src = '';
            }

            // Main try-catch block for the entire video reversal pipeline
            try {
                statusDisplay.textContent = 'Step 2: Extracting and saving frames to local store...';
                const extractionResult = await extractFramesOptimized(currentSessionId);

                statusDisplay.textContent = `Frames saved for session ${currentSessionId}. Creating reversed video...`;
                await createReversedVideoOptimized(currentSessionId, extractionResult.totalFrames);
            } catch (error) { // Catch errors from extraction or subsequent steps
                console.error("Error during video reversal pipeline:", error);
                statusDisplay.textContent = `Error: ${error.message}. Check console for details.`;
                progressBar.style.display = 'none';
                updateReverseButtonState(); // Re-enable button considering current state
            }
        });

        // --- Frame Extraction Logic ---
        /**
         * Extracts frames from the original video at a specified FPS and saves them to IndexedDB.
         * @param {string} currentSessionId - The unique ID for the current processing session.
         * @returns {Promise<object>} A promise that resolves with { totalFrames: number, sessionId: string } or rejects on critical error.
         */
        async function extractFramesOptimized(currentSessionId) {
            const duration = originalVideo.duration; // Get video duration
            const fps = parseInt(document.getElementById("fpsInput").value) || 30; // Get target FPS from input, default to 30
            const interval = 1 / fps; // Time interval between frames
            const totalFramesToExtract = Math.max(1, Math.floor(duration * fps));
            // extractedFrames = []; // No longer using global array for frame data

            console.log(`Original video duration: ${duration} seconds`);
            console.log(`Target FPS: ${fps}`);
            console.log(`Expected total frames to extract: ${totalFramesToExtract}`);

            statusDisplay.textContent = `Extracting frames at ${fps} FPS (0%)...`;
            originalVideo.pause(); // Pause the video for frame-by-frame seeking

            // Loop to extract each frame
            for (let i = 0; i < totalFramesToExtract; i++) {
                const targetTime = i * interval; // Calculate the timestamp for the current frame
                originalVideo.currentTime = Math.min(targetTime, duration); // Seek the video to the target time

                // Wait for the 'seeked' event. This ensures the video player has updated to the correct frame
                // before we try to draw it on the canvas.
                await new Promise((resolve, reject) => {
                    const seekHandler = () => {
                        originalVideo.removeEventListener('seeked', seekHandler); // Remove listener once seek is complete
                        resolve();
                    };
                    originalVideo.addEventListener('seeked', seekHandler);

                    // Fallback: If the video is already very close to the target time (e.g., for very short seeks or
                    // if currentTime was already set), the 'seeked' event might not fire.
                    // In such cases, resolve immediately if the video is ready.
                    if (originalVideo.readyState >= originalVideo.HAVE_CURRENT_DATA &&
                        Math.abs(originalVideo.currentTime - targetTime) < (interval / 2)) {
                        originalVideo.removeEventListener('seeked', seekHandler); // Clean up listener
                        resolve();
                    }
                });

                // Draw the current video frame onto the canvas
                ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height); // Clear canvas
                ctx.imageSmoothingEnabled = true; // Enable image smoothing for better quality
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(originalVideo, 0, 0, frameCanvas.width, frameCanvas.height); // Draw video frame

                await new Promise((resolveFrameSave, rejectFrameSave) => {
                    frameCanvas.toBlob(async (blob) => {
                        if (blob) {
                            const frameData = {
                                sessionId: currentSessionId,
                                frameNumber: i,
                                frameBlob: blob,
                                originalName: sourceVideoFile ? sourceVideoFile.name : 'unknown_video'
                            };
                            try {
                                await addFrameToDB(frameData);
                                // console.log(`[PROCESS] Frame ${i} for session ${currentSessionId} saved to DB.`);
                                resolveFrameSave();
                            } catch (dbError) {
                                console.error(`[PROCESS] Failed to save frame ${i} to DB.`, dbError);
                                statusDisplay.textContent = `Error saving frame ${i}. Reversal may fail.`;
                                rejectFrameSave(dbError);
                            }
                        } else {
                            console.error(`[PROCESS] Failed to create blob for frame ${i}.`);
                            statusDisplay.textContent = `Error processing frame ${i}.`;
                            rejectFrameSave(new Error(`Failed to create blob for frame ${i}.`));
                        }
                    }, 'image/png');
                });

                const progressPercentage = Math.round(((i + 1) / totalFramesToExtract) * 50);
                progressBar.value = progressPercentage;
                statusDisplay.textContent = `Extracting frames at ${fps} FPS (${progressPercentage}%)...`;
            }
            // console.log(`Successfully extracted ${extractedFrames.length} frames.`); // No longer relevant in this way
            return { totalFrames: totalFramesToExtract, sessionId: currentSessionId };
        }

        // --- Reversed Video Creation Logic ---
        /**
         * Creates a reversed video from the extracted frames using the MediaRecorder API.
         * This function also handles audio reversal if the original video has an audio track.
         * Updates progress bar and status display.
         * @param {string} currentSessionId - The ID of the current session to fetch frames for.
         * @param {number} totalFrames - The total number of frames expected for this session.
         */
        async function createReversedVideoOptimized(currentSessionId, totalFrames) {
            const fps = parseInt(document.getElementById("fpsInput").value) || 30; // Get target FPS
            return new Promise(async (resolve, reject) => {
                // if (extractedFrames.length === 0) { // Old check based on global array
                //     reject(new Error('No frames available to create video.'));
                //     return;
                // }
                // TODO: Add check if totalFrames is 0 or undefined, or if DB fetch fails later

                // Step 3: Frames are already in order in DB (0 to N-1). We'll fetch them in reverse.
                statusDisplay.textContent = 'Step 3: Preparing to fetch frames for reversal...';
                // extractedFrames.reverse(); // No longer using global array for frame data
                statusDisplay.textContent = 'Creating reversed video with lossless compression (50%)...';
                progressBar.value = 50;

                // Check for MediaRecorder API support
                if (!('MediaRecorder' in window)) {
                    reject(new Error('MediaRecorder API not supported in this browser. Cannot create downloadable video.'));
                    return;
                }

                try {
                    // NOTE ON VIDEO DURATION METADATA:
                    // MediaRecorder, especially when sourcing from a canvas stream and muxing audio,
                    // often does not write accurate duration metadata into the resulting video file's header.
                    // This can cause media players and file explorers to display the duration as 00:00
                    // or an incorrect value, even if the video plays correctly for the full length.
                    //
                    // The actual stream recorded *does* have the correct length, determined by the number
                    // of frames drawn and the FPS. The issue is purely with the metadata in the container
                    // (e.g., WebM, MP4).
                    //
                    // Robustly fixing this usually requires remuxing the generated video file with tools
                    // like ffmpeg to rebuild the container and insert correct metadata headers. This is
                    // a complex operation not easily done client-side without large libraries (e.g., ffmpeg.wasm).
                    //
                    // The current implementation attempts to mitigate this for the in-app player by
                    // displaying the original video's duration if the generated one is incorrect,
                    // but the downloaded file may still exhibit the duration issue in external players.
                    const stream = frameCanvas.captureStream(fps);
                    if (!stream) {
                        reject(new Error("Failed to capture stream from canvas."));
                        return;
                    }

                    // NOTE ON CODEC/COMPATIBILITY ISSUES (MP4/H.264):
                    // While MP4 (often with H.264 video and AAC audio) is widely supported,
                    // issues like green screens, player crashes (e.g., in VLC), or other artifacts
                    // can still occur. These are often due to factors largely outside of direct
                    // control via the MediaRecorder API:
                    //
                    // 1. Keyframe Interval: MediaRecorder uses browser-default keyframe intervals.
                    //    If these are too infrequent or not aligned with player expectations for
                    //    the specific content (reversed canvas frames), decoding errors can occur.
                    // 2. Codec Implementation: The browser's specific H.264/AAC encoder implementation
                    //    might produce streams that, while technically valid, could be problematic for
                    //    some decoders/players.
                    // 3. Player Sensitivity: Some players (like VLC) are more sensitive to minor
                    //    stream inconsistencies or missing optional metadata than others.
                    // 4. MP4 Container Structure: The way MediaRecorder packages the stream into the
                    //    MP4 container might not always include all optional information that some
                    //    players rely on for robust playback.
                    // 5. System/Driver Issues: Hardware acceleration on either the encoding (browser)
                    //    or decoding (player) side can sometimes lead to codec-specific problems.
                    //
                    // Switching to MP4 may improve compatibility for some use cases but is not a
                    // universal guarantee against playback issues. The green screen issue, in particular,
                    // often points to problems in the video track decoding, possibly related to
                    // keyframes or codec profile compatibility.

                    // NOTE ON LOW FPS AND KEYFRAME ISSUES WITH EXTERNAL PLAYERS:
                    // The MediaRecorder API does not provide direct control over keyframe intervals
                    // (GOP size) for video encoding. When using very low FPS values (e.g., 1-2 FPS),
                    // the resulting H.264 stream (even if technically valid) may have very infrequent
                    // keyframes.
                    // Some external media players (like VLC) might struggle with such streams,
                    // exhibiting behaviors like:
                    //   - Displaying only a still image (typically the first frame).
                    //   - Freezing until a new keyframe is encountered much later in the video.
                    //   - Misinterpreting the low frame rate as a lack of data.
                    // This can happen even if the browser's internal <video> player can play the
                    // generated Blob/Object URL correctly (as the browser has more context on the
                    // stream it just created).
                    // The UI provides a warning for users selecting these low FPS values.
                    // This is largely a limitation of current browser MediaRecorder implementations
                    // for fine-grained encoding control at such edge-case frame rates.
                    const mimeTypes = [
                        // Prioritize avc3 (H.264 Annex B) as suggested by browser warnings
                        'video/mp4; codecs="avc3.42E01E, mp4a.40.2"', // H.264 Baseline Profile Level 3.0 + AAC-LC
                        'video/mp4; codecs="avc3.4D401E, mp4a.40.2"', // H.264 Main Profile Level 3.0 + AAC-LC
                        'video/mp4; codecs="avc3.64001E, mp4a.40.2"', // H.264 High Profile Level 3.0 + AAC-LC

                        // Fallback to avc1 (H.264 AVCC)
                        'video/mp4; codecs="avc1.42E01E, mp4a.40.2"', // H.264 Baseline + AAC-LC
                        'video/mp4; codecs="avc1.4D401E, mp4a.40.2"', // H.264 Main + AAC-LC
                        'video/mp4; codecs="avc1.64001E, mp4a.40.2"', // H.264 High + AAC-LC
                        'video/mp4; codecs="h264, aac"',             // Generic H.264 + AAC (often implies avc1)

                        // H.264 video only (less likely to be chosen if audio is present in stream)
                        'video/mp4; codecs="avc3.42E01E"',
                        'video/mp4; codecs="avc1.42E01E"',
                        'video/mp4; codecs="h264"',

                        // Generic MP4 (let browser choose codecs)
                        'video/mp4',

                        // WebM types as ultimate fallbacks
                        'video/webm; codecs="vp9, opus"',
                        'video/webm; codecs="vp8, vorbis"',
                        'video/webm; codecs=vp9',
                        'video/webm; codecs=vp8',
                        'video/webm'
                    ];

                    let selectedMimeType = '';
                    for (const mimeType of mimeTypes) {
                        const isSupported = MediaRecorder.isTypeSupported(mimeType);
                        // Log with [INFO] prefix
                        console.log(`[INFO] Testing MIME type: ${mimeType} - Supported: ${isSupported}`);
                        // Log with [WARN-DEBUG] prefix for higher visibility (temporary)
                        console.warn(`[WARN-DEBUG] Testing MIME type: ${mimeType} - Supported: ${isSupported}`);
                        if (isSupported) {
                            selectedMimeType = mimeType;
                            // Optional: Log that this one was chosen before breaking
                            console.log(`[INFO] Using first supported MIME type: ${selectedMimeType}`);
                            console.warn(`[WARN-DEBUG] Using first supported MIME type: ${selectedMimeType}`);
                            break;
                        }
                    }
                    console.log('[INFO] Selected MIME type for MediaRecorder options:', selectedMimeType || 'default (browser will choose)');
                    console.warn('[WARN-DEBUG] Selected MIME type for MediaRecorder options:', selectedMimeType || 'default (browser will choose)');

                    // Configure MediaRecorder options, including MIME type and video bitrate for quality.
                    const recordingOptions = selectedMimeType ? {
                        mimeType: selectedMimeType,
                        videoBitsPerSecond: 15000000 // High bitrate for better quality (15 Mbps)
                    } : {
                        videoBitsPerSecond: 15000000 // Fallback if no specific MIME type is selected
                    };

                    let mediaRecorder; // The MediaRecorder instance
                    let mixedStream;   // The stream to record (can be video-only or video + reversed audio)

                    // --- Audio Reversal Handling ---
                    // If a source video file exists, attempt to extract, reverse, and re-encode its audio.
                    if (sourceVideoFile) {
                        const audioContext = new AudioContext(); // Web Audio API for audio manipulation
                        const audioFileReader = new FileReader(); // To read the audio data from the file

                        // Callback for when the audio file is loaded into an ArrayBuffer
                        audioFileReader.onload = async function() {
                            try {
                                // Decode the audio data from the ArrayBuffer
                                const audioBuffer = await audioContext.decodeAudioData(audioFileReader.result);
                                // Create a new AudioBuffer for the reversed audio
                                const reversedAudioBuffer = audioContext.createBuffer(
                                    audioBuffer.numberOfChannels,
                                    audioBuffer.length,
                                    audioBuffer.sampleRate
                                );

                                // Reverse the audio data for each channel
                                for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
                                    const channelData = audioBuffer.getChannelData(i);
                                    // `Array.from().reverse()` is used because Float32Array.reverse() is in-place
                                    reversedAudioBuffer.getChannelData(i).set(Array.from(channelData).reverse());
                                }

                                // Create an AudioBufferSourceNode to play the reversed audio
                                const source = audioContext.createBufferSource();
                                source.buffer = reversedAudioBuffer;
                                // Create a MediaStreamDestinationNode to capture the audio output as a stream
                                const dest = audioContext.createMediaStreamDestination();

                                console.log('Original video duration:', originalVideo.duration);
                                console.log('Decoded audioBuffer duration:', audioBuffer.duration);
                                console.log('Reversed audioBuffer duration:', reversedAudioBuffer.duration);

                                source.connect(dest); // Connect the source to the destination
                                source.start(); // Start playing the reversed audio (into the destination stream)
                                console.log('Reversed audio MediaStreamTrack settings:', dest.stream.getAudioTracks()[0].getSettings());

                                // Combine the video stream (from canvas) and the reversed audio stream
                                mixedStream = new MediaStream([...stream.getVideoTracks(), ...dest.stream.getAudioTracks()]);
                                try {
                                    mediaRecorder = new MediaRecorder(mixedStream, recordingOptions);
                                } catch (instantiationError) {
                                    console.error('[ERROR] Failed to instantiate MediaRecorder (with audio):', instantiationError);
                                    // Propagate or handle error: we might need to reject the main promise here
                                    // For now, mediaRecorder will remain undefined, and subsequent checks should handle it or fail.
                                    // The outer try-catch of createReversedVideoOptimized might catch this if not handled locally.
                                }
                                if (!mediaRecorder) {
                                    console.error('[CRITICAL] MediaRecorder object is not available after all instantiation attempts. Aborting video creation.');
                                    statusDisplay.textContent = 'Error: Failed to initialize video recorder. Cannot proceed.';
                                    progressBar.style.display = 'none';
                                    reverseButton.disabled = false;
                                    reject(new Error('MediaRecorder could not be instantiated. Video processing aborted.'));
                                    return;
                                }
                                startRecordingAndDrawing(mediaRecorder, resolve, reject, fps); // Proceed to record video frames

                            } catch (audioError) { // Handle errors during audio processing
                                console.error("Audio processing error:", audioError);
                                // Fallback: If audio processing fails, proceed with video-only reversal.
                                mixedStream = stream; // Use only the video stream from the canvas
                                try {
                                    mediaRecorder = new MediaRecorder(mixedStream, recordingOptions); // mixedStream here is just video
                                } catch (instantiationError) {
                                    console.error('[ERROR] Failed to instantiate MediaRecorder (audio processing fallback):', instantiationError);
                                }
                                statusDisplay.textContent = `Warning: Audio processing failed (${audioError.message}). Reversing video only.`;
                                if (!mediaRecorder) {
                                    console.error('[CRITICAL] MediaRecorder object is not available after all instantiation attempts. Aborting video creation.');
                                    statusDisplay.textContent = 'Error: Failed to initialize video recorder. Cannot proceed.';
                                    progressBar.style.display = 'none';
                                    reverseButton.disabled = false;
                                    reject(new Error('MediaRecorder could not be instantiated. Video processing aborted.'));
                                    return;
                                }
                                startRecordingAndDrawing(mediaRecorder, resolve, reject, fps);
                            }
                        };
                        // Error handler for FileReader
                        audioFileReader.onerror = (e) => {
                            console.error("Audio file reading error:", e);
                            // Fallback: If reading the audio file fails, proceed with video-only reversal.
                            mixedStream = stream;
                            try {
                                mediaRecorder = new MediaRecorder(mixedStream, recordingOptions); // mixedStream here is just video
                            } catch (instantiationError) {
                                console.error('[ERROR] Failed to instantiate MediaRecorder (audio file read error fallback):', instantiationError);
                            }
                            statusDisplay.textContent = `Warning: Could not read audio file (${e.message}). Reversing video only.`;
                            if (!mediaRecorder) {
                                console.error('[CRITICAL] MediaRecorder object is not available after all instantiation attempts. Aborting video creation.');
                                statusDisplay.textContent = 'Error: Failed to initialize video recorder. Cannot proceed.';
                                progressBar.style.display = 'none';
                                reverseButton.disabled = false;
                                reject(new Error('MediaRecorder could not be instantiated. Video processing aborted.'));
                                return;
                            }
                            startRecordingAndDrawing(mediaRecorder, resolve, reject, fps);
                        };
                        // Start reading the source video file as an ArrayBuffer for audio processing
                        audioFileReader.readAsArrayBuffer(sourceVideoFile);
                    } else {
                        // If no sourceVideoFile (e.g., if it was cleared or not loaded), proceed with video-only reversal.
                        mixedStream = stream;
                        try {
                            mediaRecorder = new MediaRecorder(mixedStream, recordingOptions); // mixedStream here is just video
                        } catch (instantiationError) {
                            console.error('[ERROR] Failed to instantiate MediaRecorder (video-only path):', instantiationError);
                        }
                        if (!mediaRecorder) {
                            console.error('[CRITICAL] MediaRecorder object is not available after all instantiation attempts. Aborting video creation.');
                            statusDisplay.textContent = 'Error: Failed to initialize video recorder. Cannot proceed.';
                            progressBar.style.display = 'none';
                            reverseButton.disabled = false;
                            reject(new Error('MediaRecorder could not be instantiated. Video processing aborted.'));
                            return;
                        }
                        startRecordingAndDrawing(mediaRecorder, resolve, reject, fps);
                    }

                } catch (e) { // Catch errors during MediaRecorder setup or stream capture
                    console.error("MediaRecorder setup or operation failed:", e);
                    reject(new Error(`Re-encoding error: ${e.message}`));
                }
            });
        }

        // --- Helper for Recording and Drawing Frames ---
        /**
         * Manages the MediaRecorder lifecycle and draws frames onto the canvas at a fixed interval
         * to be captured by the recorder.
         * @param {MediaRecorder} mediaRecorder - The configured MediaRecorder instance.
         * @param {Function} resolve - The resolve function of the parent Promise.
         * @param {Function} reject - The reject function of the parent Promise.
         * @param {number} fps - The frames per second for recording.
         */
        function startRecordingAndDrawing(mediaRecorder, resolve, reject, fps) {
            console.log('[INFO] MediaRecorder instance actually using MIME type:', mediaRecorder.mimeType);
            console.warn('[WARN-DEBUG] MediaRecorder instance actually using MIME type:', mediaRecorder.mimeType);

            const formatDisplay = document.getElementById('recordingFormatDisplay');
            if (formatDisplay) {
                let friendlyFormat = "Unknown";
                // Ensure mediaRecorder and mediaRecorder.mimeType exist before accessing
                if (mediaRecorder && mediaRecorder.mimeType) {
                    if (mediaRecorder.mimeType.includes('mp4')) {
                        friendlyFormat = "MP4";
                    } else if (mediaRecorder.mimeType.includes('webm')) {
                        friendlyFormat = "WebM";
                    } else {
                        friendlyFormat = mediaRecorder.mimeType; // Show full type if not common
                    }
                    formatDisplay.textContent = `Recording format: ${friendlyFormat}`;
                } else {
                    formatDisplay.textContent = 'Recording format: Error determining type';
                    console.error('[ERROR] Could not determine recording format because mediaRecorder or mimeType is invalid.');
                }
            }
            const chunks = []; // Array to store recorded video data chunks
            let frameIndex = 0; // Index for iterating through `extractedFrames` (which are now reversed)
            const frameDisplayInterval = 1000 / fps; // Interval in milliseconds to display each frame

            // Event handler for when data is available from MediaRecorder (i.e., a chunk of video is recorded)
            mediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    chunks.push(event.data); // Store the data chunk
                }
            };

            // Event handler for when MediaRecorder stops recording
            mediaRecorder.onstop = function() {
                if (chunks.length === 0) { // Check if any data was recorded
                    statusDisplay.textContent = 'Re-encoding failed: No data recorded.';
                    progressBar.style.display = 'none';
                    reverseButton.disabled = false;
                    reject(new Error("MediaRecorder produced no data. This can happen if codecs are unsupported or resources are too constrained."));
                    return;
                }

                // Create a Blob from the recorded chunks. This Blob is the final reversed video file.
                const blobMimeType = chunks[0].type || mediaRecorder.mimeType || 'video/webm'; // Determine MIME type of the blob
                const blob = new Blob(chunks, { type: blobMimeType });

                // Revoke any existing object URL for the reversed video before creating a new one
                if (currentReversedVideoObjectURL) {
                    URL.revokeObjectURL(currentReversedVideoObjectURL);
                }
                currentReversedVideoObjectURL = URL.createObjectURL(blob); // Create object URL for the new blob

                // Set the source of the reversed video player and the download link
                reversedVideo.src = currentReversedVideoObjectURL;
                downloadButton.href = currentReversedVideoObjectURL;
                // Determine file extension based on MIME type
                // const extension = blobMimeType.includes('mp4') ? 'mp4' : 'webm'; // Old line
                let extension = 'webm'; // Default to webm
                if (blobMimeType.includes('mp4')) {
                    extension = 'mp4';
                } else if (blobMimeType.includes('webm')) {
                    extension = 'webm';
                } // Add more else-if for other types if necessary, though mp4 and webm are primary.
                downloadButton.download = `reversed_video_${Date.now()}.${extension}`; // Set download filename
                downloadButton.style.display = 'inline-block'; // Show the download button

                // Display performance results
                const processingTime = ((performance.now() - processingStartTime) / 1000).toFixed(1);
                const outputSize = formatFileSize(blob.size);

                statusDisplay.textContent = 'âœ… Video successfully reversed with optimized compression!';
                performanceInfo.innerHTML = `
                    <strong>Processing Complete:</strong> ${processingTime}s â€¢ Output: ${outputSize} â€¢
                    ${extractedFrames.length} frames @ ${fps} FPS â€¢ ${frameCanvas.width}x${frameCanvas.height}
                `;

                progressBar.value = 100; // Set progress to 100%
                setTimeout(() => { progressBar.style.display = 'none'; }, 3000); // Hide progress bar after a delay
                reverseButton.disabled = false; // Re-enable the reverse button
                resolve(); // Resolve the main promise indicating success
            };

            // Error handler for MediaRecorder
            mediaRecorder.onerror = (event) => {
                console.error("MediaRecorder error:", event.error || event);
                let errorMessage = "MediaRecorder error during recording.";
                if (event.error && event.error.name) {
                    errorMessage += ` Name: ${event.error.name}.`;
                }
                if (event.error && event.error.message) {
                    errorMessage += ` Message: ${event.error.message}.`;
                }
                reject(new Error(errorMessage));
            };

            mediaRecorder.start(); // Start recording the stream

            // Use setInterval to draw frames onto the canvas at the specified FPS.
            // The MediaRecorder captures these frames from the canvas stream.
            const drawingInterval = setInterval(() => {
                if (frameIndex < extractedFrames.length) { // If there are more frames to draw
                    const img = new Image(); // Create an Image element to load the data URL
                    img.onload = () => { // When the frame image is loaded
                        // Draw the frame onto the canvas
                        ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, frameCanvas.width, frameCanvas.height);

                        // Update progress (re-encoding part, from 50% to 100%)
                        const progressPercentage = 50 + Math.round((frameIndex / extractedFrames.length) * 50);
                        progressBar.value = progressPercentage;
                        statusDisplay.textContent = `Creating reversed video (${progressPercentage}%)...`;

                        frameIndex++; // Move to the next frame
                    };
                    // Error handler if a frame image fails to load
                    img.onerror = () => {
                        console.error(`Error loading frame image ${frameIndex} (data URL) for re-encoding.`);
                        frameIndex++; // Skip the problematic frame and try to continue
                    };
                    img.src = extractedFrames[frameIndex]; // Set the source of the image to the frame's data URL
                } else { // All frames have been drawn
                    clearInterval(drawingInterval); // Stop the drawing interval
                    if (mediaRecorder.state === "recording") { // Check if MediaRecorder is still recording
                        mediaRecorder.stop(); // Stop recording
                    }
                }
            }, frameDisplayInterval); // Set interval timing based on FPS
        }

        // --- Memory Management and Cleanup ---
        // Event listener for 'beforeunload' (when the user is about to leave the page).
        // This is important for revoking object URLs to free up browser memory.
        window.addEventListener('beforeunload', () => {
            if (currentOriginalVideoObjectURL) { // If an object URL for the original video exists
                URL.revokeObjectURL(currentOriginalVideoObjectURL); // Revoke it
            }
            if (currentReversedVideoObjectURL) { // If an object URL for the reversed video exists
                URL.revokeObjectURL(currentReversedVideoObjectURL); // Revoke it
            }
        });
    </script>
</body>
</html>
